desc:rjc test

import cookdsp.jsfx-inc

slider1:s_shift=0.3<0.0, 1.0, 0.01>Shifting Frequency (Hz)
slider2:s_mix=1.0<0,1,0.05>Mix
slider3:s_phase1=0.15<0.0,1.0,0.05>Phase 1
slider4:s_phase2=0.15<0.0,1.0,0.05>Phase 2

slider5:s_base=100.0<100.0, 1000.0, 10.0>Base frequency
slider6:s_max_frequency=8000<1000, 20000, 10.0>Max frequency
slider7:s_spacing=1.8<1.0, 2.0, 0.01>Band spacing
slider8:s_bandcount=1<1, 20, 1>Band count
slider9:s_q=0<0.0, 20.0, 0.01>Q
slider10:s_funky=0<0, 1, 1{off, on}>Funky

slider11:s_solo=0<0, 31, 1>Solo

slider12:s_message=0<0, 4, 1{ready, init, slider, solo, error}>Message
slider13:s_debug1=0<0, 99999.00>Debug 1
slider14:s_debug2=0<0, 99999.00>Debug 2



@init
function set_debug1 ( x) ( 
s_debug1 == 0 ? (
s_debug1 = x;
slider_automate(s_debug1);
);
); // set_debug1

function set_debug2 ( x) ( 
s_debug2 == 0 ? (
s_debug2 = x;
slider_automate(s_debug2);
);
); // set_debug2

m_ready = 0;
m_init = 1;
m_slider = 2;
m_solo = 3;
m_error = 4;

function set_message (n) (
message != m_error ? (
s_message = n;
slider_automate(s_message);
);
); // set_message


function freq(base, band, spacing) (
base * spacing^band;
); // freq

function calculate_bandcount (base, max_frequency, spacing)
local (count) (
count = 1;
while (freq(base, count, spacing) <= max_frequency) (
count += 1;
); // while

count - 1;
); // calculate_bandcount

function update_parameters (base, max_frequency, spacing)
local (bandcount, i) (

bandcount = calculate_bandcount(base, max_frequency, spacing);
s_bandcount = bandcount;
slider_automate(s_bandcount);

this.frequency = set(bandcount, 0);
this.q = set(bandcount, 0);

i = 1;
while(i <= bandcount) (
this.frequency[i] = freq(base, i, spacing);
this.q[i] = 1 / this.freq(base, i+1, spacing);
i += 1;
); // while

bandcount;
); // update_parameters

function transform (input, q1, q2) (
// Hilbert transform
hilbert.hilbert_do(input);

this.mod1 = hilbert.real * q1;
this.mod2 = hilbert.imag * q2;

// Sideband separation
this.down = this.mod1 + this.mod2;
this.up = this.mod1 - this.mod2;
); // transform


wet_gain = s_mix;
dry_gain = 1 - abs(s_mix);
output_gain = 2 - abs(wet_gain - dry_gain);

ph.phasor(s_shift, 0);
hilbert.hilbert();

bandcount = filter.update_parameters(s_base, s_max_frequency, s_spacing);
bps.Pbutbp(filter.frequency, filter.q);

set_message(m_init);
filter.frequency[0] != bandcount ? set_message(m_error);

@slider
wet_gain = s_mix;
dry_gain = 1 - abs(s_mix);
output_gain = 2 - abs(wet_gain - dry_gain);
ph.phasor(s_shift, 0);

bandcount = filter.update_parameters(s_base, s_max_frequency, s_spacing);
bps.Pbutbp_set_freq(filter.frequency);
bps.Pbutbp_set_q(	filter.q);

set_message(m_slider);
filter.frequency[0] != bandcount ? set_message(m_error);


@sample
out_left = 0;
out_right = 0;
input = 0.7 * (spl0 + spl1);
bps_out = bps.Pbutbp_do(tmp(spl0, spl1));
set_debug1(bps_out[0]);
bps_out[0] != bandcount ? set_message(m_error);

// Complex phase
s_shift > 0 ? (
ph1 = ph.phasor_do();
ph2 = wrap(ph1+s_phase1, 0, 1);
q1 = sin(2 * $pi * ph1);
q2 = sin(2 * $pi * ph2);

) : (
ph1 = s_phase1;
ph2 = s_phase2;
q1 = sin(2 * $pi * ph1);
q2 = cos(2 * $pi * ph2);
);


s_solo > bandcount ? (
s_solo = bandcount;
slider_automate(s_solo);

) : s_solo > 0 && s_solo <= s_bandcount ? (
filtered_sample = bps_out[s_solo];
tr.transform(filtered_sample, q1, q2);
out_left = filtered_sample + tr.up;
out_right = filtered_sample - tr.down;
set_message(m_solo);

) : (
s_message != m_slider ? set_message(m_slider);

i=1;
while (i <= s_bandcount) (
filtered_sample = bps_out[i] / bandcount;
// Hilbert transform
tr.transform(filtered_sample, q1, q2);

s_funky > 0 && i % 2 > 0 ? (
out_right += (filtered_sample + tr.mod1);
out_left += (filtered_sample - tr.mod2);

) : (
out_left += (filtered_sample + tr.up);
out_right += (filtered_sample - tr.down);
);

i += 1;
); // while

); // solo

spl0 = output_gain * (dry_gain * spl0 + wet_gain * out_left);
spl1 = output_gain * (dry_gain * spl1 + wet_gain * out_right);
