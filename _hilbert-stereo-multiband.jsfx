desc: old


import cookdsp.jsfx-inc

slider1:s_shift=0.3<0.0, 1.0, 0.01>Shifting Frequency (Hz)
slider2:s_mix=1.0<0,1,0.05>Mix
slider3:s_phase1=0.7<0.0,1.0,0.05>Phase 1
slider4:s_phase2=0.45<0.0,1.0,0.05>Phase 2

slider5:s_base=100.0<100.0, 1000.0, 10.0>Base frequency
slider6:s_max_frequency=8000<1000, 20000, 10.0>Max frequency
slider7:s_spacing=1.45<1.0, 2.0, 0.01>Band spacing
slider8:s_bandcount=1<1, 20, 1>Band count
slider9:s_mode=2<0, 5, 1>Mode
slider10:s_solo=0<0, 31, 1>Solo




@init
function random (a, b) (
rand(1) * abs(b-a) + a;
); // random
 


function freq(base, band, spacing) (
base * spacing^band;
); // freq

function calculate_bandcount (base, max_frequency, spacing)
local (count) (
count = 1;
while (freq(base, count, spacing) <= max_frequency) (
count += 1;
); // while

count - 1;
); // calculate_bandcount

function update_parameters (base, max_frequency, spacing)
local (bandcount, i) (

bandcount = calculate_bandcount(base, max_frequency, spacing);
s_bandcount = bandcount;
slider_automate(s_bandcount);

bandcount > this._bandcount ? (
this.frequency = set(bandcount, 0);
this.q = set(bandcount, 0);
this._bandcount = bandcount;
);

i = 1;
while(i <= bandcount) (
this.frequency[i] = freq(base, i, spacing);
this.q[i] = 1 / this.freq(base, i+1, spacing);
i += 1;
); // while

bandcount;
); // update_parameters

function transform (input, q1, q2) (
// Hilbert transform
hilbert.hilbert_do(input);

this.mod1 = hilbert.real * q1;
this.mod2 = hilbert.imag * q2;

// Sideband separation
this.down = this.mod1 + this.mod2;
this.up = this.mod1 - this.mod2;
); // transform


wet_gain = s_mix;
dry_gain = 1 - abs(s_mix);
output_gain = 2 - abs(wet_gain - dry_gain);

ph.phasor(s_shift, 0);
hilbert.hilbert();

bandcount = filter.update_parameters(s_base, s_max_frequency, s_spacing);
left.Pbutbp(filter.frequency, filter.q);
right.Pbutbp(filter.frequency, filter.q);


@slider
wet_gain = s_mix;
dry_gain = 1 - abs(s_mix);
output_gain = 2 - abs(wet_gain - dry_gain);
ph.phasor(s_shift, 0);

bandcount = filter.update_parameters(s_base, s_max_frequency, s_spacing);
left.Pbutbp_set_freq(filter.frequency);
left.Pbutbp_set_q(	filter.q);
right.Pbutbp_set_freq(filter.frequency);
right.Pbutbp_set_q(	filter.q);



@sample
out_left = 0;
out_right = 0;
left.out = left.Pbutbp_do(tmp(spl0));
right.out = right.Pbutbp_do(tmp(spl1));
//right.out = right.Pbutbp_do(tmp(spl0));

// Complex phase
s_shift > 0 ? (
ph1 = ph.phasor_do();
ph2 = wrap(ph1+s_phase1, 0, 1);
q1 = sin(2 * $pi * ph1);
q2 = sin(2 * $pi * ph2);

) : (
ph1 = s_phase1;
ph2 = s_phase2;
q1 = sin(2 * $pi * ph1);
q2 = cos(2 * $pi * ph2);
);


s_solo > bandcount ? (
s_solo = bandcount;
slider_automate(s_solo);

) : s_solo > 0 && s_solo <= s_bandcount ? (
l = left.out[s_solo];
left.transform(l, q1, q2);
r = left.out[s_solo];
right.transform(r, q1, q2);
out_left = 0.7 * (l+r) + left.up + right.up + left.down + right.down;
out_right = 0.7 * (l+r) + left.up + right.up - left.down - right.down;


) : (
// all bands

i=1;
while (i <= s_bandcount) (
l = left.out[i] / bandcount;
r = right.out[i] / bandcount;

// modes 0, 1, 3, and 4 use two hilbert transforms so are much more processor intensive
s_mode == 0 ? (
left.transform(l, q1, q2);
right.transform(r, q1, q2);

out_left += (r + right.mod1 + right.mod2);
out_right += (l - left.mod1 - left.mod2);

) : s_mode == 1 ? (
left.transform(l, q1, q2);
right.transform(r, q1, q2);

out_left += (l + left.mod1 + left.mod2);
out_right += (r - right.mod1 - right.mod2);

) : s_mode == 2 ? (
tr.transform(l+r, q1, q2);

out_left += (l + tr.up);
out_right += (r - tr.down);


) : s_mode == 3 ? (
tr.transform(2*(l-r), q1, q2);

out_left += (r + tr.up);
out_right += (l - tr.down);

) : s_mode == 4 ? (
left.transform(2 * (l-r), q1, q2);
right.transform(0.5 * (l+r), q1, q2);

out_left += 0.5 * (l+r) + left.up + right.up;
out_right += 0.5 * (-l+r) - left.down - right.down;
//out_right += 2*(l-r) - tr.mod2;
) : s_mode == 5 ? (


);

i += 1;
); // while

); // solo

spl0 = output_gain * (dry_gain * spl0 + wet_gain * out_left);
spl1 = output_gain * (dry_gain * spl1 + wet_gain * out_right);
